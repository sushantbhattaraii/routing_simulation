<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Server Timeline Slider</title>
  <style>
    :root {
      --bg: #f7f7f8;
      --panel: #ffffff;
      --ink: #111827;
      --muted: #6b7280;
      --stroke: #d1d5db;
      --shadow: 0 6px 24px rgba(0,0,0,.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--ink);
    }

    /* Horizontal form / header */
    .topbar {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 12px 16px;
      background: var(--panel);
      box-shadow: var(--shadow);
      position: sticky;
      top: 0;
      z-index: 10;
      flex-wrap: wrap;
    }

    .topbar .group {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    label {
      font-size: 14px;
      color: var(--muted);
    }

    input[type="number"]{
      width: 96px;
      padding: 8px 10px;
      border: 1px solid var(--stroke);
      border-radius: 10px;
      outline: none;
      font-size: 14px;
      background: #fff;
    }

    button {
      padding: 9px 12px;
      border: 1px solid var(--stroke);
      border-radius: 10px;
      background: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover { filter: brightness(0.98); }

    .pill {
      border: 1px solid var(--stroke);
      border-radius: 999px;
      padding: 8px 12px;
      background: #fff;
      font-size: 13px;
      color: var(--ink);
      white-space: nowrap;
    }

    .pill b { font-weight: 650; }
    .muted { color: var(--muted); }

    /* Canvas should cover the whole webpage horizontally */
    #wrap {
      width: 100%;
      padding: 0;
    }

    canvas {
      display: block;
      width: 100vw;          /* cover whole page horizontally */
      height: calc(100vh - 64px);
      background: transparent;
    }

    .hint {
      margin-left: auto;
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
    }

    /* Bottom-center dock, side-by-side */
    #statsDock{
    position: fixed;
    left: 50%;
    bottom: 12px;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    align-items: flex-end;
    z-index: 20;
    max-width: calc(100vw - 24px);
    }

    /* Each panel box */
    .miniPanel{
    background: rgba(255,255,255,0.96);
    border: 1px solid var(--stroke);
    border-radius: 16px;
    box-shadow: var(--shadow);
    padding: 12px 12px 10px;
    width: min(520px, calc((100vw - 36px)/2));
    max-height: 34vh;      /* keeps sliders visible */
    overflow: auto;
    }

    /* On small screens, stack them */
    @media (max-width: 900px){
    #statsDock{
        flex-direction: column;
        align-items: center;
    }
    .miniPanel{
        width: min(520px, calc(100vw - 24px));
    }
    }


    .panelTitle{
    font-size: 13px;
    font-weight: 650;
    color: var(--ink);
    margin: 2px 0 8px;
    }

    .distanceList{ display:flex; flex-direction:column; gap:8px; }

    .distRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding: 8px 10px;
    border: 1px solid rgba(209,213,219,0.75);
    border-radius: 12px;
    background: #fff;
    }

    .swatch{
    display:inline-block;
    width: 10px;
    height: 10px;
    border-radius: 999px;
    margin-right: 8px;
    border: 1px solid rgba(0,0,0,0.15);
    vertical-align: middle;
    }

    .tableWrap{ overflow:auto; border:1px solid rgba(209,213,219,0.75); border-radius: 12px; background:#fff; }
    #stateTable{ width:100%; border-collapse: collapse; font-size: 12.5px; }
    #stateTable th, #stateTable td{ padding: 8px 10px; border-bottom: 1px solid rgba(209,213,219,0.6); text-align: left; white-space: nowrap; }
    #stateTable thead th{ position: sticky; top: 0; background: #fff; z-index: 1; }
    #stateTable tbody tr:last-child td{ border-bottom: none; }

  </style>
</head>
<body>
  <div class="topbar">
    <div class="group">
      <label for="kInput">#Servers (k)</label>
      <input id="kInput" type="number" min="2" step="1" max="7" value="2" />
      <button id="applyBtn" type="button">Apply</button>
    </div>

    <div class="group" aria-live="polite">
      <span id="alphaPill" class="pill"><span class="muted">α</span> = <b>—</b></span>
      <span id="betaPill" class="pill"><span class="muted">β</span> = <b>—</b></span>
      <span id="relationPill" class="pill"><span class="muted">relation</span>: <b>α + β = 1</b></span>
      <span id="cardPill" class="pill"><span class="muted">cardinality</span>: <b>|α| = 1</b>, <b>|β| = k−1</b></span>
    </div>

    <div class="hint">Drag the colored dots on each server line</div>
  </div>

  <div id="wrap">
    <canvas id="c"></canvas>
    <!-- Visible stats + table panel -->
    <div id="statsDock">
        <div class="miniPanel">
            <div class="panelTitle">Server movement</div>
            <div id="distanceList" class="distanceList"></div>
        </div>

        <div class="miniPanel">
            <div class="panelTitle">Per-server time-step table</div>
            <div class="tableWrap">
            <table id="stateTable"></table>
            </div>
        </div>
        </div>

  </div>

  <script>
    // ======= Config =======
    const T_MIN = 0;
    const T_MAX = 18;
    // Tick spacing depends on k: tickStep = alpha = 1/(2k-1)
let tickStep = 1; // set to alpha when k is applied

function tickCount() {
  // number of tickStep steps between 0 and 18
  return Math.round((T_MAX - T_MIN) / tickStep);
}

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    const kInput = document.getElementById('kInput');
    const applyBtn = document.getElementById('applyBtn');

    const alphaPill = document.getElementById('alphaPill');
    const betaPill = document.getElementById('betaPill');
    const cardPill = document.getElementById('cardPill');

    // Panel elements
    const distanceList = document.getElementById('distanceList');
    const stateTable = document.getElementById('stateTable');

    // Per-server state
    let servers = []; // { id, color, value } where value in [0, 18]

    // Movement tracking
    let totalDistance = [];   // cumulative distance traveled by each server
    let moveHistory = [];     // per server: array of committed positions (per-step)
    let dragStartValue = 0;   // value when a drag starts (for distance calc)


    // Drag state
    let draggingId = null;
    let dragOffsetX = 0;

    // Layout (computed)
    const layout = {
      padL: 90,
      padR: 24,
      padT: 36,
      padB: 28,
      tickLen: 10,
      lineGap: 70,
      knobR: 9,
      labelW: 78,
      axisY: 24,
      axisLabelY: 16,
    };

    // Use a stable, distinct palette.
    // If k is larger than palette length, we generate hues.
    const basePalette = [
      '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
      '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
    ];

    function colorFor(i, k) {
      if (i < basePalette.length) return basePalette[i];
      // Generate more colors (golden angle)
      const hue = (i * 137.508) % 360;
      return `hsl(${hue} 70% 45%)`;
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // Convert time value -> x coordinate
    function xForTime(t) {
      const w = canvas.width;
      const x0 = layout.padL;
      const x1 = w - layout.padR;
      const u = (t - T_MIN) / (T_MAX - T_MIN);
      return x0 + u * (x1 - x0);
    }

    // Convert x coordinate -> time value
    function timeForX(x) {
      const w = canvas.width;
      const x0 = layout.padL;
      const x1 = w - layout.padR;
      const u = (x - x0) / (x1 - x0);
      return T_MIN + clamp(u, 0, 1) * (T_MAX - T_MIN);
    }

    // Snap a time value to the nearest multiple of tickStep (= alpha)
    function snapToStep(t) {
      const step = tickStep;
      const n = Math.round((t - T_MIN) / step);
      return T_MIN + n * step;
    }

    function yForServerIndex(i) {
      // i is 0-based
      return layout.padT + layout.axisY + 30 + i * layout.lineGap;
    }

    let currentK = parseInt(kInput.value, 10) || 1;

    function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b) [a, b] = [b, a % b];
    return a || 1;
    }

    function formatFractionFromTime(t) {
    // Since t is always snapped to multiples of alpha, t = num/(2k-1)
    const denom = 2 * currentK - 1;
    if (denom <= 1) return String(Math.round(t)); // k=1 => denom=1

    let num = Math.round(t * denom);

    // Reduce fraction
    const g = gcd(num, denom);
    num /= g;
    const d = denom / g;

    // If it becomes an integer, show as integer
    if (d === 1) return String(num);

    const sign = num < 0 ? "-" : "";
    num = Math.abs(num);

    const whole = Math.floor(num / d);
    const rem = num % d;

    if (rem === 0) return sign + String(whole);
    if (whole === 0) return sign + `${rem}/${d}`;
    return sign + `${whole} ${rem}/${d}`;
    }

    function computeAlphaBeta(k) {
      // As given: alpha = 1/(2k-1), beta = 2*alpha
      // Note: Then alpha + beta = 3/(2k-1), which equals 1 only when k=2.
      // We will still display alpha+beta=1 as the stated relation, but keep the given formulas.
      const alpha = 1 / (2 * k - 1);
      const beta = 2 * alpha;
      return { alpha, beta };
    }

    function updatePills(k) {
    currentK = k; // IMPORTANT: keep denominator synced
    const denom = 2 * k - 1;

    alphaPill.innerHTML =
        `<span class="muted">α</span> = <b>1/${denom}</b> <span class="muted">(1/(2k−1))</span>`;

    betaPill.innerHTML  =
        `<span class="muted">β</span> = <b>2/${denom}</b> <span class="muted">(2α)</span>`;

    cardPill.innerHTML  =
        `<span class="muted">cardinality</span>: <b>|α| = 1</b>, <b>|β| = k−1</b> <span class="muted">(k=${k})</span>`;
    }

    function setServers(k) {
    servers = Array.from({ length: k }, (_, i) => ({
        id: i,
        color: colorFor(i, k),
        value: 0
    }));

    // Start everyone at origin (0)
    for (let i = 0; i < servers.length; i++) {
        servers[i].value = 0;
    }

    // Init movement tracking
    totalDistance = Array(k).fill(0);
    moveHistory = Array.from({ length: k }, () => []);

    renderDistances();
    renderTable();
    }


    // Canvas sizing for crisp rendering
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const cssW = Math.floor(window.innerWidth);
      const cssH = Math.floor(window.innerHeight - document.querySelector('.topbar').getBoundingClientRect().height);

      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';

      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }

    // ======= Drawing =======
    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // background
      ctx.fillStyle = 'rgba(255,255,255,0)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawAxis() {
      const w = canvas.width;
      const h = canvas.height;
      const x0 = layout.padL;
      const x1 = w - layout.padR;

      // Baseline for timeline (top axis)
      const y = layout.padT;

      // Axis line
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x0, y);
      ctx.lineTo(x1, y);
      ctx.stroke();

      // Ticks are spaced by alpha (= tickStep). For readability, we only label integers (0..18).
      ctx.fillStyle = '#111827';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';

      const steps = tickCount();
      for (let i = 0; i <= steps; i++) {
        const t = T_MIN + i * tickStep;
        const x = xForTime(t);

        const isInteger = Math.abs(t - Math.round(t)) < 1e-9;
        const len = isInteger ? layout.tickLen : Math.max(4, Math.floor(layout.tickLen * 0.55));

        ctx.strokeStyle = '#111827';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y - len);
        ctx.stroke();

        if (isInteger) {
          ctx.fillText(String(Math.round(t)), x, y - layout.tickLen - 4);
        }
      }

      // Left vertical spine
      const spineX = x0;
      const spineTop = y;
      const spineBottom = yForServerIndex(Math.max(servers.length - 1, 0)) + 30;
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(spineX, spineTop);
      ctx.lineTo(spineX, clamp(spineBottom, spineTop, h - layout.padB));
      ctx.stroke();
    }

    function drawServerLine(server, idx) {
      const w = canvas.width;
      const x0 = layout.padL;
      const x1 = w - layout.padR;
      const y = yForServerIndex(idx);

      // Label
      ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#111827';
      const label = (idx === servers.length - 1 && servers.length > 5)
        ? 'Server K'
        : `Server ${idx + 1}`;
      ctx.fillText(label, x0 - 12, y);

      // Line
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x0, y);
      ctx.lineTo(x1, y);
      ctx.stroke();

      // Start dot at left (black)
      ctx.fillStyle = '#111827';
      ctx.beginPath();
      ctx.arc(x0, y, 6, 0, Math.PI * 2);
      ctx.fill();

      // Knob (colored)
      const knobX = xForTime(server.value);
      ctx.fillStyle = server.color;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(knobX, y, layout.knobR, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Value bubble
      const bubbleText = formatFractionFromTime(server.value);
      const bw = ctx.measureText(bubbleText).width + 12;
      const bx = clamp(knobX, x0 + bw/2, x1 - bw/2);
      const by = y - 22;

      // Bubble background
      ctx.fillStyle = 'rgba(17,24,39,0.06)';
      roundRect(bx - bw/2, by - 14, bw, 22, 10);
      ctx.fill();

      ctx.fillStyle = '#111827';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(bubbleText, bx, by - 3);
    }

    function roundRect(x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function draw() {
      clear();
      drawAxis();
      // Server lines
      for (let i = 0; i < servers.length; i++) {
        drawServerLine(servers[i], i);
      }

      // Soft instruction at bottom
      ctx.fillStyle = 'rgba(17,24,39,0.55)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
      ctx.fillText('Timeline 0–18 (unit tick spacing = 1). Drag any colored knob to move that server along its line.', layout.padL, canvas.height - 14);
    }

    // ======= Stats rendering =======
    function fmtVisible(t) {
    // Uses your fraction formatter if you added it earlier.
    return (typeof formatFractionFromTime === 'function')
        ? formatFractionFromTime(t)
        : t.toFixed(4);
    }

    function renderDistances() {
    if (!distanceList) return;
    distanceList.innerHTML = servers.map((s, i) => {
        const label = (i === servers.length - 1 && servers.length > 5) ? 'Server K' : `Server ${i + 1}`;
        return `
        <div class="distRow">
            <div><span class="swatch" style="background:${s.color}"></span><b>${label}</b></div>
            <div><span class="muted">total distance</span>: <b>${fmtVisible(totalDistance[i] || 0)}</b></div>
        </div>
        `;
    }).join('');
    }

    function renderTable() {
    if (!stateTable) return;
    const k = servers.length;
    const maxSteps = moveHistory.reduce((m, arr) => Math.max(m, arr.length), 0);

    // Header
    let html = '<thead><tr>';
    html += '<th>timestep</th>';
    for (let i = 0; i < k; i++) {
        const label = (i === k - 1 && k > 5) ? 'Server K' : `Server ${i + 1}`;
        html += `<th>${label}</th>`;
    }
    html += '</tr></thead>';

    // Body
    html += '<tbody>';
    for (let step = 1; step <= maxSteps; step++) {
        html += `<tr><td><b>${step}</b></td>`;
        for (let i = 0; i < k; i++) {
        const v = moveHistory[i][step - 1];
        html += `<td>${(v === undefined) ? '—' : fmtVisible(v)}</td>`;
        }
        html += '</tr>';
    }
    html += '</tbody>';

    stateTable.innerHTML = html;
    }


    // ======= Interaction (dragging knobs) =======
    function getPointerPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left);
      const y = (evt.clientY - rect.top);
      return { x, y };
    }

    function hitTestKnob(px, py) {
      for (let i = 0; i < servers.length; i++) {
        const s = servers[i];
        const y = yForServerIndex(i);
        const x = xForTime(s.value);
        const dx = px - x;
        const dy = py - y;
        if (dx*dx + dy*dy <= (layout.knobR + 6) * (layout.knobR + 6)) {
          return { id: s.id, idx: i, knobX: x, knobY: y };
        }
      }
      return null;
    }

    canvas.addEventListener('pointerdown', (evt) => {
    canvas.setPointerCapture(evt.pointerId);
    const { x, y } = getPointerPos(evt);
    const hit = hitTestKnob(x, y);
    if (hit) {
        draggingId = hit.id;
        dragOffsetX = x - hit.knobX;

        // Record where this server was when the drag started
        const s = servers.find(ss => ss.id === draggingId);
        dragStartValue = s ? s.value : 0;
    }
    });

    canvas.addEventListener('pointermove', (evt) => {
      if (draggingId === null) return;
      const { x } = getPointerPos(evt);
      const s = servers.find(ss => ss.id === draggingId);
      if (!s) return;

      const newTime = timeForX(x - dragOffsetX);
      s.value = clamp(snapToStep(newTime), T_MIN, T_MAX);
      draw();
    });

    function endDrag(evt) {
    if (draggingId !== null) {
        const s = servers.find(ss => ss.id === draggingId);
        if (s) {
        const idx = s.id;

        // Total distance traveled during this drag (added cumulatively)
        const moved = Math.abs(s.value - dragStartValue);
        if (moved > 0) {
            totalDistance[idx] = (totalDistance[idx] || 0) + moved;

            // Per-server timestep: record the committed location
            moveHistory[idx].push(s.value);

            renderDistances();
            renderTable();
        }
        }

        draggingId = null;
        draw();
    }
    }

    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', endDrag);


    // ======= Form handling =======
    function applyK() {
      const k = clamp(parseInt(kInput.value || '1', 10) || 1, 1, 200);
      kInput.value = String(k);
      // Update alpha/beta and set tickStep to alpha
      const { alpha } = computeAlphaBeta(k);
      tickStep = alpha;

      updatePills(k);
      setServers(k);
      resizeCanvas();
    }

    applyBtn.addEventListener('click', applyK);
    kInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') applyK();
    });

    // ======= Init =======
    const k0 = parseInt(kInput.value, 10) || 1;
    const { alpha: alpha0 } = computeAlphaBeta(k0);
    tickStep = alpha0;
    updatePills(k0);
    setServers(k0);

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Note for later: sub-intervals (Beta * 2^i repeated k-1 times + Alpha * 2^i once)
    // are intentionally NOT drawn per your instruction; they can be added later.
  </script>
</body>
</html>
